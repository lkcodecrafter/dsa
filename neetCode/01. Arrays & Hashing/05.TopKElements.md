# 347. Top K Frequent Elements
Medium

Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.

 

Example 1:
```
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
```
Example 2:
```
Input: nums = [1], k = 1
Output: [1]
 ```

Constraints:

- 1 <= nums.length <= 105
- k is in the range [1, the number of unique elements in the array].
- It is guaranteed that the answer is unique.
 

### Follow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size.
```java

class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> mp = new HashMap<>();
        int[] res = new int[k];
        for(int num : nums) {
            mp.put(num, mp.getOrDefault(num,0)+1);
        }
        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b)->b.val-a.val);
        for(int key : mp.keySet())
            pq.offer(new Pair(key, mp.get(key)));
        for(int i = 0; i < k; i++)
            res[i] = pq.poll().key;
        
        return res;
    }
}

class Pair {
    int key;
    int val;
    
    Pair(int k, int v) {
        key = k;
        val = v;
    }
}


# Java Array & Heap Problems

## 1️⃣ Top K Frequent Elements

### Problem
Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in any order.

---

### Approach: HashMap + Max Heap

#### Steps
1. **Count Frequencies**
   - Use `HashMap<Integer,Integer>` to store `element → frequency`.
   
2. **Store in Max Heap**
   - Create `PriorityQueue<Pair>` sorted by frequency descending `(a,b) -> b.val - a.val`.
   
3. **Extract k Elements**
   - Poll the heap `k` times and store the keys in result array.

#### Time Complexity
- Build map: **O(n)**
- Heap insert: **O(n log n)**
- Poll k: **O(k log n)**
- **Overall:** O(n log n)

#### Space Complexity
O(n)

---

### Example
Input:
```
nums = [1,1,1,2,2,3], k = 2
```
Frequency Map:
```
1 → 3
2 → 2
3 → 1
```
Max heap order (by frequency):
```
[(1,3), (2,2), (3,1)]
```
Poll k=2 → `[1, 2]`

---

Step-by-step:
PriorityQueue<Pair>

This is a heap that will store objects of type Pair.

By default, a PriorityQueue in Java is min-heap (smallest element comes first).

If we want max-heap (largest first), we must give it a custom comparator.

(a, b) -> b.val - a.val

This is a lambda expression (short form of writing a function).

Here, a and b are two Pair objects being compared.

We compare their val fields:

b.val - a.val means:

If b.val > a.val, result is positive ⇒ b comes before a.

This makes the queue sort by val in descending order (largest frequency first).

Why needed here?

You want the most frequent elements first.

So the val (frequency) is sorted from high to low.

Then when you do pq.poll(), you get the Pair with the highest frequency first.

💡 Simple analogy:
Think of PriorityQueue<Pair> like a VIP line at a club.

Each Pair is a person,

val is how famous they are.

(a, b) -> b.val - a.val says: "Put the most famous people at the front of the line."

If you want, I can dry run your whole code with an example like nums = [1,1,1,2,2,3], k=2 so you see how this queue actually orders things. That will make it crystal clear.


```
