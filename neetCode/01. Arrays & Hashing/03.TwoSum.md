# 1. Two Sum
Easy

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

 

Example 1:
```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```
Example 2:
```
Input: nums = [3,2,4], target = 6
Output: [1,2]
```
Example 3:
```
Input: nums = [3,3], target = 6
Output: [0,1]
 ```

Constraints:

- 2 <= nums.length <= 104
- -109 <= nums[i] <= 109
- -109 <= target <= 109
- Only one valid answer exists.
 

Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int n = nums.length;
        Map<Integer, Integer> map = new HashMap<>();
        
        for(int i = 0; i < n; i++) {
            int remaining = target-nums[i]; // the value we need to find
            if(map.containsKey(remaining)) {
                return new int[] {map.get(remaining), i}; // we found the pair!
            }
            map.put(nums[i], i); // store current number and its index
        }
        return new int[]{-1, -1};
    }
}
```
ðŸ§  Explanation
ðŸ”¸ map.put(nums[i], i);
We store the current number (nums[i]) as a key and its index (i) as the value.

Purpose: So we can look it up later when we're checking future numbers.

ðŸ”¸ return new int[] {map.get(remaining), i};
If weâ€™ve already seen the number that can pair with nums[i] to make the target (i.e., remaining), we:

Get its index using map.get(remaining)

Return an array with both indices:

First index: the one we saw earlier (from the map)

Second index: the current index i

ðŸ’¡ Example
java
Copy
Edit
nums = [2, 7, 11, 15]
target = 9
We want 2 + 7 = 9, so return [0, 1].

Step-by-step:

i = 0 â†’ nums[0] = 2

remaining = 9 - 2 = 7

map does not contain 7

Store 2 in map â†’ map = {2: 0}

i = 1 â†’ nums[1] = 7

remaining = 9 - 7 = 2

map contains 2 â†’ we found a pair!

Return: new int[] {map.get(2), 1} â†’ new int[] {0, 1}

âœ… We found the indices of two numbers that add to the target.

âœ… Summary (in Markdown-style)
md
Copy
Edit
- `map.put(nums[i], i)` stores the current number and its index.
- `remaining = target - nums[i]` calculates what number we need.
- If `map.containsKey(remaining)` is true:
  - We already saw the matching number earlier.
  - `map.get(remaining)` gives its index.
  - `i` is the current index.
  - Return both indices in an array.