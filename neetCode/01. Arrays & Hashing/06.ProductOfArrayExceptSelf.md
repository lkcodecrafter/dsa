# 238. Product of Array Except Self
Medium


Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.

You must write an algorithm that runs in O(n) time and without using the division operation.

 

Example 1:
```
Input: nums = [1,2,3,4]
Output: [24,12,8,6]
```
Example 2:
```
Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]
 ```

Constraints:

- 2 <= nums.length <= 105
- -30 <= nums[i] <= 30
- The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
 

### Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];
        int pre = 1;
        res[0] = 1;
        for(int i = 0; i < n-1; i++) {
            pre *= nums[i];
            res[i+1] = pre;
        }
        int post = 1;
        for(int i = n-1; i > 0; i--) {
            post *= nums[i];
            res[i-1] *= post;
        }
        return res;
    }
}
```


## 2️⃣ Product of Array Except Self

### Problem
Given an array `nums`, return an array `res` where `res[i]` = product of all elements in `nums` except `nums[i]`, without using division.

---

### Approach: Prefix and Suffix Products (O(1) extra space)

#### Idea
`res[i]` = (product of all numbers before i) × (product of all numbers after i)

#### Steps
1. **First pass (Prefix)**
   - `pre = 1`, `res[0] = 1`
   - For i = 0 → n-2:
     - `pre *= nums[i]`
     - `res[i+1] = pre`

2. **Second pass (Suffix)**
   - `post = 1`
   - For i = n-1 → 1:
     - `post *= nums[i]`
     - `res[i-1] *= post`

---

### Dry Run Example
nums = [1, 2, 3, 4]

**First pass (prefix in res):**
```
res[0] = 1
i=0 → pre=1 → res[1] = 1
i=1 → pre=2 → res[2] = 2
i=2 → pre=6 → res[3] = 6
res = [1, 1, 2, 6]
```

**Second pass (suffix multiply):**
```
post = 1
i=3 → post=4 → res[2] = 2*4 = 8
i=2 → post=12 → res[1] = 1*12 = 12
i=1 → post=24 → res[0] = 1*24 = 24
res = [24, 12, 8, 6]
```

Output:
```
[24, 12, 8, 6]
```

---

### Time Complexity
O(n) (2 passes)

### Space Complexity
O(1) extra (excluding result array)


First Loop (Prefix Pass)


int pre = 1;
res[0] = 1;  // No numbers before index 0 → product is 1

for(int i = 0; i < n-1; i++) {
    pre *= nums[i];      // multiply previous product with current element
    res[i+1] = pre;      // store this prefix product at the NEXT index
}
Why i+1?
Because the product at index i+1 should not include nums[i+1] itself.
Example:
nums = [1, 2, 3, 4]
Prefix pass builds:
res[0] = 1
res[1] = nums[0] = 1
res[2] = nums[0] * nums[1] = 2
res[3] = nums[0] * nums[1] * nums[2] = 6

This way res[i] = product of all numbers before index i.

Second Loop (Suffix Pass)


int post = 1;

for(int i = n-1; i > 0; i--) {
    post *= nums[i];       // multiply previous product from the right
    res[i-1] *= post;      // multiply prefix result with suffix product
}
Why i-1?
Because the suffix product should be stored one index before the current.
At index i-1, we want:

res[i-1] = (prefix product before i-1) × (product of elements after i-1)
✅ In short:

res[i+1] in first loop → storing prefix for next index.

res[i-1] in second loop → multiplying suffix into previous index.


pre and post start as 1 because 1 is the multiplicative identity — multiplying by 1 doesn’t change the value.

When calculating product of elements before or after an index, starting with 1 means:

For the very first element, the product of elements before it is empty → so product = 1.

Similarly, for the last element, product of elements after it is empty → product = 1.

So, initializing pre = 1 and post = 1 correctly handles edges without extra checks.
