# 11. Container With Most Water
Medium

You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return the maximum amount of water a container can store.

Notice that you may not slant the container.

 

Example 1:
```
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
```
Example 2:
```
Input: height = [1,1]
Output: 1
 ```

Constraints:

- n == height.length
- 2 <= n <= 105
- 0 <= height[i] <= 104

```java
class Solution {
    public int maxArea(int[] height) {
        int area = 0, maxArea = 0;
        int left = 0, right = height.length-1;
        
        while(left < right) {
            area = Math.min(height[left], height[right])*(right-left);
            maxArea = Math.max(maxArea, area);
            if(height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        
        return maxArea;
    }
}
```
# Container With Most Water — Two Pointers Approach

---

## Problem

Given an array `height` where each element represents the height of a vertical line on the x-axis,  
find two lines that together with the x-axis form a container that holds the most water.  
Return the maximum amount of water the container can store.

---

## Approach: Two Pointers

1. **Initialize two pointers:**  
   - `left` at the start (0)  
   - `right` at the end (`height.length - 1`)

2. **Calculate area formed between the lines at `left` and `right`:**  

area = min(height[left], height[right]) * (right - left)


- The height is limited by the shorter line.
- The width is the distance between `left` and `right`.

3. **Keep track of the maximum area found so far.**

4. **Move pointers inward to find potentially bigger area:**  
- If `height[left] < height[right]`, move `left++` (try to find taller left line)  
- Else move `right--` (try to find taller right line)

5. **Repeat until `left` meets `right`.**

---

## Explanation

- The key insight is that the container's volume is limited by the shorter of the two lines.  
- By moving the pointer at the shorter line inward, you might find a taller line that can form a larger container, possibly increasing the area.  
- Moving the pointer at the taller line inward will only decrease the width without increasing height, so it won't increase the area.  
- This greedy approach efficiently checks all possible pairs in **O(n)** time.

---

## Time Complexity

- `O(n)`, where `n` is the length of the height array.

---

## Space Complexity

- `O(1)`, no extra space needed.

---

### Explanation of

```java
area = Math.min(height[left], height[right]) * (right - left);
height[left] and height[right] are the heights of the two lines at the current pointers.

The container's water level can only be as high as the shorter of these two lines, because water would spill over the shorter one.

So, Math.min(height[left], height[right]) gives the effective height of the water container.

(right - left) is the distance (width) between the two lines on the x-axis.

Multiplying these gives the area (volume) of water the container can hold between these two lines.

In simple terms:

The container’s capacity = (shorter line’s height) × (distance between the lines)

# Dry Run of Container With Most Water

Consider the input:

```java
height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
Initialization:
left = 0 (height = 1)

right = 8 (height = 7)

maxArea = 0

Step 1:
Calculate area = min(1, 7) * (8 - 0) = 1 * 8 = 8

maxArea = max(0, 8) = 8

Since height[left] < height[right], move left to 1

Step 2:
left = 1 (height = 8)

right = 8 (height = 7)

area = min(8, 7) * (8 - 1) = 7 * 7 = 49

maxArea = max(8, 49) = 49

height[left] > height[right], so move right to 7

Step 3:
left = 1 (height = 8)

right = 7 (height = 3)

area = min(8, 3) * (7 - 1) = 3 * 6 = 18

maxArea = max(49, 18) = 49

height[left] > height[right], move right to 6

Step 4:
left = 1 (height = 8)

right = 6 (height = 8)

area = min(8, 8) * (6 - 1) = 8 * 5 = 40

maxArea = max(49, 40) = 49

height[left] == height[right], move right to 5

Step 5:
left = 1 (height = 8)

right = 5 (height = 4)

area = min(8, 4) * (5 - 1) = 4 * 4 = 16

maxArea = max(49, 16) = 49

height[left] > height[right], move right to 4

Step 6:
left = 1 (height = 8)

right = 4 (height = 5)

area = min(8, 5) * (4 - 1) = 5 * 3 = 15

maxArea = max(49, 15) = 49

height[left] > height[right], move right to 3

Step 7:
left = 1 (height = 8)

right = 3 (height = 2)

area = min(8, 2) * (3 - 1) = 2 * 2 = 4

maxArea = max(49, 4) = 49

height[left] > height[right], move right to 2

Step 8:
left = 1 (height = 8)

right = 2 (height = 6)

area = min(8, 6) * (2 - 1) = 6 * 1 = 6

maxArea = max(49, 6) = 49

height[left] > height[right], move right to 1

Loop ends because left is no longer less than right.
Final result:
Maximum area found = 49