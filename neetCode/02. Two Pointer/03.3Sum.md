# 15. 3Sum
Medium


Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

Notice that the solution set must not contain duplicate triplets.

 

Example 1:
```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
```
Example 2:
```
Input: nums = []
Output: []
```
Example 3:
```
Input: nums = [0]
Output: []
 ```

Constraints:

- 0 <= nums.length <= 3000
- -10<sup>5</sup> <= nums[i] <= 10<sup>5</sup>

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        for(int i = 0; i < nums.length-2; i++) {
            if(i > 0 && nums[i] == nums[i-1])
                continue;
            search(i, nums, result);
        }
        return result;
    }
    
    private void search(int index, int[] nums, List<List<Integer>> result) {
        int left = index+1, right = nums.length-1;
        while(left < right) {
            int sum = nums[index] + nums[left] + nums[right];
            if(sum == 0) {
                result.add(Arrays.asList(nums[index], nums[left], nums[right]));
                left++;
                right--;
                while(left < right && nums[left]==nums[left-1])
                    left++;
                while(left < right && nums[right]==nums[right+1])
                    right--;
            } else if(sum < 0) {
                left++;
            } else {
                right--;
            }
        }
    }
}
```

# 3Sum Problem (LeetCode #15) — Two Pointers Solution

This is a **Two Pointers** solution for the 3Sum problem.  
It finds all unique triplets in the array whose sum is zero.

---

## 1. Problem

Given an array `nums`, find all unique triplets `[a, b, c]` such that:

a + b + c = 0
---

## 2. Approach

### Step 1: Sort the array

Sorting helps in:

- Skipping duplicates easily
- Using two pointers for finding pairs

---

### Step 2: Iterate for the first number

```java
for (int i = 0; i < nums.length - 2; i++) {
    if (i > 0 && nums[i] == nums[i - 1]) continue; // skip duplicates
    search(i, nums, result);
}

nums[i] is fixed as the first number.

We call search() to find two other numbers that sum to -nums[i].

Step 3: Two-Pointer Search
 
int left = index + 1, right = nums.length - 1;
left starts just after index.

right starts at the last element.

Step 4: Calculate the sum
 
int sum = nums[index] + nums[left] + nums[right];
If sum == 0 → found a triplet

If sum < 0 → need a bigger sum → move left++

If sum > 0 → need a smaller sum → move right--

Step 5: Skip duplicates
 
while (left < right && nums[left] == nums[left - 1]) left++;
while (left < right && nums[right] == nums[right + 1]) right--;
This avoids repeating the same triplet.

Dry Run
Example:

 
nums = [-1, 0, 1, 2, -1, -4]
Step 1: Sort
 
[-4, -1, -1, 0, 1, 2]
Step 2: i = 0 (-4)
left=1 (-1), right=5 (2)

sum = -4 + (-1) + 2 = -3 → too small → move left++

...

Step 3: i = 1 (-1)
left=2 (-1), right=5 (2)

sum = -1 + (-1) + 2 = 0 → triplet found → add [-1, -1, 2]

skip duplicates

next: left=3 (0), right=4 (1)

sum = -1 + 0 + 1 = 0 → triplet found → add [-1, 0, 1]

...

Output:
 
[[-1, -1, 2], [-1, 0, 1]]
⏳ Time Complexity
Sorting: O(n log n)

Outer loop: O(n)

Inner two-pointer: O(n)

Overall: O(n^2)

Explanation of nums[i - 1]
In this line:

 
if (i > 0 && nums[i] == nums[i - 1]) continue;
nums[i - 1] means the number immediately before nums[i] in the sorted array.

Why check this?
After sorting, duplicates are adjacent.

If we've already considered nums[i - 1] as the first element of a triplet, then nums[i] having the same value would produce the same triplet again.

So, we skip duplicates to avoid redundant work.

Example:
Sorted array:

css
Copy
Edit
[-4, -1, -1, 0, 1, 2]
When i = 1 → nums[i] = -1, nums[i - 1] = -4 → different → proceed.

When i = 2 → nums[i] = -1, nums[i - 1] = -1 → same → skip (continue) because triplets with -1 already handled at i=1.

Key point
nums[i - 1] is just array indexing to look at the previous element and detect duplicates when the array is sorted.