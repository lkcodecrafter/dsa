# 3. Longest Substring Without Repeating Characters
Medium


Given a string s, find the length of the longest substring without repeating characters.

 

Example 1:
```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
```
Example 2:
```
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
```
Example 3:
```
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
 ```

Constraints:

- 0 <= s.length <= 5 * 104
- s consists of English letters, digits, symbols and spaces.

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> mp = new HashMap<>();
        int maxLen = 0, winStart = 0;
        
        for(int winEnd = 0; winEnd < s.length(); winEnd++) {
            char ch = s.charAt(winEnd);
            if(mp.containsKey(ch)) {
                winStart = Math.max(winStart, mp.get(ch)+1);
            }
            mp.put(ch, winEnd);
            maxLen = Math.max(winEnd - winStart + 1, maxLen);
        }
        return maxLen;        
    }
}
```
Problem Statement
Given a string s, find the length of the longest substring without repeating characters.

Example:

Input: "abcabcbb"

Output: 3 ("abc" is the longest substring without repeating characters)

Approach (Sliding Window with HashMap)
Idea
We maintain a sliding window to keep track of a substring without duplicates.
A HashMap stores each character and its most recent index.

winStart → start index of the current window.

winEnd → end index (loop variable).

maxLen → maximum window length found so far.

Step-by-step
Initialize:

winStart = 0 (window start)

maxLen = 0

HashMap mp to store char → lastIndex

Traverse string using winEnd:

Let ch = s.charAt(winEnd)

If ch is already in the map, it means this character was already seen in the current window.

Move winStart to max of current winStart and lastIndex+1
This ensures we skip over the duplicate's previous position.

Update the map: mp.put(ch, winEnd)

Calculate current window length: winEnd - winStart + 1

Update maxLen if needed.

After the loop, maxLen contains the answer.

Dry Run Example
Input: "abcabcbb"

winEnd	ch	mp(before)	Duplicate?	winStart update	mp(after)	maxLen
0	a	{}	No	0	{a:0}	1
1	b	{a:0}	No	0	{a:0, b:1}	2
2	c	{a:0, b:1}	No	0	{a:0, b:1, c:2}	3
3	a	{a:0, b:1, c:2}	Yes	1	{a:3, b:1, c:2}	3
4	b	{a:3, b:1, c:2}	Yes	2	{a:3, b:4, c:2}	3
5	c	{a:3, b:4, c:2}	Yes	3	{a:3, b:4, c:5}	3
6	b	{a:3, b:4, c:5}	Yes	5	{a:3, b:6, c:5}	3
7	b	{a:3, b:6, c:5}	Yes	7	{a:3, b:7, c:5}	3

Result: maxLen = 3

Time & Space Complexity
Time Complexity: O(n)
Each character is processed at most twice (once when seen, once when window start moves).

Space Complexity: O(min(n, m))
Where m is the charset size (for ASCII, m = 128).

README.md
markdown
Copy
Edit
# Longest Substring Without Repeating Characters

## Problem
Given a string `s`, find the length of the **longest substring** without repeating characters.

**Example**
Input: "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.

markdown
Copy
Edit

## Approach
We use a **sliding window** technique with a **HashMap** to store the last seen index of each character.

### Steps:
1. Initialize:
   - `winStart = 0`
   - `maxLen = 0`
   - HashMap `mp` (char → last index)

2. Traverse string with `winEnd`:
   - If character already exists in map:
     - Move `winStart` to `max(winStart, lastIndex+1)`
   - Update map with current index.
   - Calculate window size and update `maxLen`.

3. Return `maxLen`.

## Complexity
- **Time:** O(n)
- **Space:** O(min(n, charset_size))

## Code (Java)
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> mp = new HashMap<>();
        int maxLen = 0, winStart = 0;

        for (int winEnd = 0; winEnd < s.length(); winEnd++) {
            char ch = s.charAt(winEnd);
            if (mp.containsKey(ch)) {
                winStart = Math.max(winStart, mp.get(ch) + 1);
            }
            mp.put(ch, winEnd);
            maxLen = Math.max(maxLen, winEnd - winStart + 1);
        }
        return maxLen;
    }
}
 

 