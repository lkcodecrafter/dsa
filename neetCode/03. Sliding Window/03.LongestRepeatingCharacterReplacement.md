# 424. Longest Repeating Character Replacement
Medium


You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.

Return the length of the longest substring containing the same letter you can get after performing the above operations.

 

Example 1:
```
Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.
```
Example 2:
```
Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
``` 

Constraints:

- 1 <= s.length <= 10<sup>5</sup>
- s consists of only uppercase English letters.
- 0 <= k <= s.length

## Notes
```
- use a map to store the frequency
- maxRepeatingCharCount = max(maxRepeatingCharCount, mp.get(char))
- slide the left pointer until the equation satifies: windowEnd - windowStart + 1 - maxRepeatingCharCount > k
- maxLen = max(maxLen, windowEnd - windowStart + 1)
```

## Solution:
```java
class Solution {
    public int characterReplacement(String s, int k) {
        int windowStart = 0, maxLength = 0, mostRepeatingCharCount = 0;
        
        HashMap<Character, Integer> charFreqMap = new HashMap();
        
        for(int windowEnd = 0; windowEnd < s.length(); windowEnd++) {
            char right = s.charAt(windowEnd);
            charFreqMap.put(right, charFreqMap.getOrDefault(right, 0)+1);
            mostRepeatingCharCount = Math.max(mostRepeatingCharCount, charFreqMap.get(right));
            
            while(windowEnd-windowStart+1 - mostRepeatingCharCount > k) {
                char left = s.charAt(windowStart);
                charFreqMap.put(left, charFreqMap.get(left)-1);
                if(charFreqMap.get(left) == 0)
                    charFreqMap.remove(left);
                windowStart++;
            }
            maxLength = Math.max(maxLength, windowEnd-windowStart+1);
        }
        
        return maxLength;
    }
}
```


Itâ€™s not actually replacing the characters in the string â€” itâ€™s simulating the replacement using math and the sliding window logic.

Letâ€™s break it down:

What the problem says
Weâ€™re allowed to replace at most k characters in the string so that all characters in some substring are the same.
We need to find the length of the longest such substring.

Example:
s = "AABABBA", k = 1 â†’ Replace one B with A â†’ "AAAA BBA" â†’ "AABA BBA" â†’ longest is "AABA" with length 4.

How this code works without actual replacement
Sliding Window

We expand the window (windowEnd) one character at a time.

We keep track of how many times each character appears inside this window (charFreqMap).

mostRepeatingCharCount

This is the count of the most frequent character in the current window.

Example: window "AABA" â†’ frequency: {A: 3, B: 1} â†’ mostRepeatingCharCount = 3.

How it simulates replacement

In any window, the number of characters weâ€™d need to replace to make them all the same is:

javascript
Copy
Edit
window length - mostRepeatingCharCount
Example: "AABA" â†’ length = 4, mostRepeatingCharCount = 3 â†’ we need 4 - 3 = 1 replacement (change the B to A).

Check if replacements exceed k

If window length - mostRepeatingCharCount > k, we canâ€™t make this window valid with only k changes.

So we shrink the window from the left (windowStart++).

Track max length

If the window is valid (replacements â‰¤ k), update maxLength.

Dry run
s = "AABABBA", k = 1

Step	Window	Freq Map	Most Frequent Count	Needed Changes	Valid?	maxLength
1	A	{A:1}	1	0	Yes	1
2	AA	{A:2}	2	0	Yes	2
3	AAB	{A:2, B:1}	2	1	Yes	3
4	AABA	{A:3, B:1}	3	1	Yes	4
5	AABAB	{A:3, B:2}	3	2	No	â€”
shrink	ABAB	{A:2, B:2}	2	2	No	â€”
shrink	BAB	{A:1, B:2}	2	1	Yes	4
6	BABB	{A:1, B:3}	3	1	Yes	4
7	BABBA	{A:2, B:3}	3	2	No	â€”
shrink	ABBA	{A:2, B:2}	2	2	No	â€”
shrink	BBA	{A:1, B:2}	2	1	Yes	4

Result â†’ maxLength = 4

âœ… Key point: The actual string stays unchanged â€” we just count how many replacements would be needed in each window and check if thatâ€™s â‰¤ k.

If you want, I can make a visual diagram showing the window expanding and shrinking for this exact example so you can see the replacement logic in action. That would make it even easier to remember. Would you like me to do that?








You said:
can you explain code lines


ChatGPT said:
Alright â€” letâ€™s go line by line through your code so you can see exactly what each part is doing.
Iâ€™ll break it into sections so itâ€™s clear.

1. Variable setup
java
Copy
Edit
int windowStart = 0, maxLength = 0, mostRepeatingCharCount = 0;
HashMap<Character, Integer> charFreqMap = new HashMap();
windowStart â†’ left pointer of the sliding window.

maxLength â†’ keeps track of the longest valid substring found.

mostRepeatingCharCount â†’ count of the most frequent character in the current window.

charFreqMap â†’ stores frequency of each character in the current window.

2. Expanding the window
java
Copy
Edit
for (int windowEnd = 0; windowEnd < s.length(); windowEnd++) {
    char right = s.charAt(windowEnd);
    charFreqMap.put(right, charFreqMap.getOrDefault(right, 0) + 1);
    mostRepeatingCharCount = Math.max(mostRepeatingCharCount, charFreqMap.get(right));
Loop: windowEnd is the right pointer, moving forward through the string.

char right = s.charAt(windowEnd); â†’ current character at the right edge.

charFreqMap.put(...) â†’ increase its count in the map.

Update mostRepeatingCharCount â†’ find the highest frequency so far in the window.

3. Checking if replacements exceed k

    while (windowEnd - windowStart + 1 - mostRepeatingCharCount > k) {
        char left = s.charAt(windowStart);
        charFreqMap.put(left, charFreqMap.get(left) - 1);
        if (charFreqMap.get(left) == 0)
            charFreqMap.remove(left);
        windowStart++;
    }

windowEnd - windowStart + 1 â†’ current window length.

- mostRepeatingCharCount â†’ how many characters are not the most frequent one.

If this number is greater than k, it means weâ€™d need more than k replacements â†’ shrink window from the left.

Reduce frequency of the left char in the map.

If count becomes 0, remove it from the map (to keep the map clean).

Move windowStart forward.

4. Updating maximum length
java
Copy
Edit
    maxLength = Math.max(maxLength, windowEnd - windowStart + 1);
}
After adjusting the window (if needed), we calculate its length and update maxLength if itâ€™s the largest seen so far.

5. Returning the result
java
Copy
Edit
return maxLength;
Finally, we return the maximum valid window length found.

ðŸ’¡ Core Logic Summary:

Keep expanding the window.

Track frequency of characters.

If the number of replacements needed is more than k, shrink the window from the left.

Keep track of the largest valid window length.
