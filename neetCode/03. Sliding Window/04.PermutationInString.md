# 567. Permutation in String
Medium


Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.

In other words, return true if one of s1's permutations is the substring of s2.

 

Example 1:
```
Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains one permutation of s1 ("ba").
```
Example 2:
```
Input: s1 = "ab", s2 = "eidboaoo"
Output: false
 ```

Constraints:

- 1 <= s1.length, s2.length <= 10<sup>4</sup>
- s1 and s2 consist of lowercase English letters.

## Approach
```
- 2 array of size 26 to keep count of chars present in both the strings[s1 and substring of s2]
- match keeps the number of characters matches in both s1 and substring of s2
- if matches = 26, we have a permutation in that window
- on each window, we check for conditions [ for both the chars(at left and at right) ]:
  - increment s2Map[rightCharInd]++ and decrement s2Map[leftCharInd]--
  - if the char's count are same increment the matches
  - if the char's count differ by 1 
    - right: s1Map[rightCharInd] + 1 == s2Map[rightCharInd], 
    - left: s1Map[leftCharInd] - 1 == s2Map[leftCharInd] decrement the matches
```

## Solution
```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        if(s1.length() > s2.length())
            return false;
        char[] s1Map = new char[26];
        char[] s2Map = new char[26];
        
        for(int i = 0; i < s1.length(); i++) {
            s1Map[s1.charAt(i)-'a']++;
            s2Map[s2.charAt(i)-'a']++;
        }
            
        int matches = 0;
        for(int i = 0; i < 26; i++) {
            if(s1Map[i] == s2Map[i])
                matches++;
        }
        int windowStart = 0;
        for(int windowEnd = s1.length(); windowEnd < s2.length(); windowEnd++) {
            if(matches == 26) return true;
            int rightCharInd = s2.charAt(windowEnd)-'a';
            s2Map[rightCharInd]++;
            if(s1Map[rightCharInd] == s2Map[rightCharInd])
                matches++;
            else if(s1Map[rightCharInd] + 1 == s2Map[rightCharInd])
                matches--;
            
            int leftCharInd = s2.charAt(windowStart)-'a';
            s2Map[leftCharInd]--;
            if(s1Map[leftCharInd] == s2Map[leftCharInd])
                matches++;
            else if(s1Map[leftCharInd] - 1 == s2Map[leftCharInd])
                matches--;
            
            windowStart++;
        }
        
        return matches == 26;
    }
}
```
## Complexity Analysis:
```
Time Complexity: O(s2.length())
Space Complexity: O(26) ~ O(1)
```
## Solution
```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int arrs1[] = new int[26], arrs2[] = new int [26];

        // ch - 'a' = a - a = 97-97 = 0->1
        // ch - 'b' = b -a  - 98-97 = 1->
        // we increasd the frequency

        for(char ch : s1.toCharArray()){
            arrs1[ch - 'a'] += 1;
        }

        //taken window size as s1.lenght()-1
        int window = s1.length() - 1;
        int r = 0;
        while(r < s2.length()){

            //inluding the character
            arrs2[s2.charAt(r) - 'a'] += 1;
            
            if(r >= window){
                if(match(arrs1, arrs2)) return true;
                
                //removing the character
                arrs2[s2.charAt(r - window) - 'a'] -= 1;
            }
            r++;
        }
        return false;
    }
    private static boolean match(int arrs1[], int arrs2[]){
        for(int i=0; i<26; i++){
            if(arrs1[i] != arrs2[i]) return false;
        }
        return true;
    }
```


âœ… Code Purpose

The goal is to check whether any permutation of s1 exists in s2.

This is the classic Permutation in String problem.

Example:
s1 = "ab"
s2 = "eidbaooo"

â†’ substring "ba" is a permutation of "ab" â†’ return true.

âœ… High-Level Logic

Count frequency of each character in s1 â†’ arrs1

Slide a window of size = s1.length() over s2

For each window:

Add new character (right side)

Check if window matches permutation (compare arrays)

Remove old character (left side)

If at any time frequencies match â†’ return true

We use fixed window size = s1.length().

ğŸ§  Understanding Line by Line
### Line 1
int arrs1[] = new int[26], arrs2[] = new int[26];


We create two frequency arrays:

arrs1 â†’ stores char freq of s1

arrs2 â†’ stores freq of current window in s2

### Line 5â€“8: Build frequency for s1
for(char ch : s1.toCharArray()){
    arrs1[ch - 'a'] += 1;
}


Example s1 = "ab":

'a' â†’ index 0 â†’ arrs1[0] = 1

'b' â†’ index 1 â†’ arrs1[1] = 1

So:

arrs1 = [1, 1, 0, 0, ..., 0]

### Set sliding window parameters
int window = s1.length() - 1;


If s1 = "ab" â†’ window = 2 - 1 = 1

This means we check for match when:

right_index >= 1


Why -1?
Because:

When r = 1 â†’ window size = 2 (which equals s1.length)

### Start sliding window
int r = 0;
while(r < s2.length()){


We iterate through each char in s2.

### Include right character into the window
arrs2[s2.charAt(r) - 'a'] += 1;


This adds the character at position r to arrs2.

### When window size reaches s1 length
if(r >= window){


This means current window is big enough to compare.

Inside this:

1ï¸âƒ£ Check match
if(match(arrs1, arrs2)) return true;


If both frequency arrays equal â†’ permutation found.

2ï¸âƒ£ Slide window forward

Remove the leftmost character:

arrs2[s2.charAt(r - window) - 'a'] -= 1;


This makes the window slide by 1.

### Increment r
r++;

ğŸ“Œ match() Function
private static boolean match(int arrs1[], int arrs2[]){
    for(int i=0; i<26; i++){
        if(arrs1[i] != arrs2[i]) return false;
    }
    return true;
}


Returns true only if all frequency counts match.

âœ… NOW â€” FULL DRY RUN

Let's dry run with:

s1 = "ab"
s2 = "eidbaooo"

ğŸŸ¦ Step 1 â€” Build s1 frequency

s1 = "ab":

arrs1 = [1,1,0,0,0,0,0,...0]

ğŸŸ¦ Step 2 â€” Set window size
window = s1.length() - 1 = 1


Window size becomes 2 â†’ which matches s1â€™s length.

ğŸŸ¦ Step 3 â€” Start sliding on s2
â–¶ Iteration 1: r = 0

s2[r] = 'e'

Add 'e':

arrs2['e']++  â†’ arrs2[4] = 1


r < window (0 < 1) â†’ window not big enough yet
âœ” No match check
âœ” No removal

â–¶ Iteration 2: r = 1

s2[r] = 'i'

Add 'i':

arrs2['i']++ â†’ arrs2[8] = 1


Now r >= window
because 1 >= 1

âœ” Check match(arrs1, arrs2)

arrs1 = [1,1,0,0,0,...]

arrs2 = [0,0,0,0,1,0,0,0,1...]

â†’ Not equal â†’ continue

Remove leftmost char = s2[r - window] = s2[1 - 1] = s2[0] = 'e':

arrs2['e']-- â†’ arrs2[4] = 0

â–¶ Iteration 3: r = 2

s2[r] = 'd'

Add 'd':

arrs2['d']++ â†’ arrs2[3] = 1


r = 2 >= 1 â†’ check match
â†’ Not equal

Remove left char = s2[2-1] = s2[1] = 'i':

arrs2['i']-- â†’ arrs2[8] = 0

â–¶ Iteration 4: r = 3

s2[r] = 'b'

Add 'b':

arrs2['b']++ â†’ arrs2[1] = 1


Now arrs2 looks like:

index 1 (b): 1


Check match
â†’ Not equal

Remove left char = s2[3 - 1] = s2[2] = 'd':

arrs2['d']-- â†’ arrs2[3] = 0

â–¶ Iteration 5: r = 4

s2[r] = 'a'

Add 'a':

arrs2['a']++ â†’ arrs2[0] = 1


Now:

arrs2 = [1,1,0,0,0,...]


Check match:

arrs1 = [1,1,0,0,0,...]
arrs2 = [1,1,0,0,0,...]


ğŸ‰ Arrays match â†’ return true

We found substring "ba" which is permutation of "ab".

ğŸ‰ FINAL RESULT
true

â¤ï¸ Summary â€” WHY IT WORKS

It builds frequency array of s1

Slides a fixed-size window on s2

Keeps frequency of characters within window

Compares frequency arrays

If equal â†’ permutation found

Very clean and efficient (O(n)).